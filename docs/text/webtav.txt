
webtav package
**************


Submodules
==========


webtav.flasknado module
=======================

class class webtav.flasknado.Flasknado(*args, **kwargs)

   Bases: "flask.views.MethodView"

   Create a Flask Handler which looks and smells like Tornado.

   add_header(name, value)

      Adds the given response header and value.

   clear_header(name)

      Clears an outgoing header, undoing a previous *set_header* call.

      Note that this method does not apply to multi-valued headers set
      by *add_header*.

   cookies

      An alias for *self.request.cookies
      <.httpserver.HTTPRequest.cookies>*.

   create_signed_value(name, value)

      Signs and timestamps a string so it cannot be forged.

      Normally used via set_secure_cookie, but provided as a separate
      method for non-cookie uses.  To decode a value not stored as a
      cookie use the optional value argument to get_secure_cookie.

   decode_argument(value, name=None)

      Decodes an argument from the request.

      The argument has been percent-decoded and is now a byte string.
      By default, this method decodes the argument as utf-8 and
      returns a unicode string, but this may be overridden in
      subclasses.

      This method is used as a filter for both *get_argument()* and
      for values extracted from the url and passed to
      *get()*/*post()*/etc.

      The name of the argument is provided if known, but may be None
      (e.g. for unnamed groups in the url regex).

   get_argument(name, default=[], strip=True)

      Returns the value of the argument with the given name.

      If default is not provided, the argument is considered to be
      required, and we raise a *MissingArgumentError* if it is
      missing.

      If the argument appears in the url more than once, we return the
      last value.

      The returned value is always unicode.

   get_arguments(name, strip=True)

      Returns a list of the arguments with the given name.

      If the argument is not present, returns an empty list.

      The returned values are always unicode.

   get_body_arguments(name, strip=True)

      Returns a list of the body arguments with the given name.

      If the argument is not present, returns an empty list.

      The returned values are always unicode.

      New in version 3.2.

   get_query_argument(name, default=[], strip=True)

      Returns the value of the argument with the given name from the
      request query string.

      If default is not provided, the argument is considered to be
      required, and we raise a *MissingArgumentError* if it is
      missing.

      If the argument appears in the url more than once, we return the
      last value.

      The returned value is always unicode.

      New in version 3.2.

   get_query_arguments(name, strip=True)

      Returns a list of the query arguments with the given name.

      If the argument is not present, returns an empty list.

      The returned values are always unicode.

      New in version 3.2.

   get_secure_cookie(name, value=None, max_age_days=31)

      Returns the given signed cookie if it validates, or None.

      The decoded cookie value is returned as a byte string (unlike
      *get_cookie*).

   get_status()

      Returns the status code for our response.

   redirect(url, permanent=False, status=None)

      Sends a redirect to the given (optionally relative) URL.

      If the "status" argument is specified, that value is used as the
      HTTP status code; otherwise either 301 (permanent) or 302
      (temporary) is chosen based on the "permanent" argument. The
      default is 302 (temporary).

   set_cookie(name, value, **kwargs)

      Sets the given cookie name/value with the given options.

   set_header(name, value)

      Sets the given response header name and value.


webtav.uimodules module
=======================

class class webtav.uimodules.NewMessage(handler)

   Bases: "tornado.web.UIModule"

   Prints the form to submit a new message

   javascript_files()

      Add the JS files that are specific to newmessages

   render(template, *args, **kwargs)

class class webtav.uimodules.ShowAttachments(handler)

   Bases: "tornado.web.UIModule"

   Show the Global Menu (generally the first pane on the left)

   render(envelope)

class class webtav.uimodules.ShowGlobalmenu(handler)

   Bases: "tornado.web.UIModule"

   Show the Global Menu (generally the first pane on the left)

   render()

class class webtav.uimodules.ShowMessage(handler)

   Bases: "tornado.web.UIModule"

   Show a Tavern Message.

   render(envelope, top)

class class webtav.uimodules.ShowMessagelist(handler)

   Bases: "tornado.web.UIModule"

   Show the Message List (generally the middle pane)

   render()

class class webtav.uimodules.ShowPrivateMessagelist(handler)

   Bases: "tornado.web.UIModule"

   Show the Global Menu (generally the first pane on the left)

   render(messages)

class class webtav.uimodules.ShowUserdetails(handler)

   Bases: "tornado.web.UIModule"

   Show the Global Menu (generally the first pane on the left)

   render(envelope, note=None)

class class webtav.uimodules.xsrf_form_html(handler)

   Bases: "tornado.web.UIModule"

   Includes the XSRF token as a hidden variable. This overwrites the
   default tornado xsrf_form_html, with a version that includes via
   SSI.

   render()


webtav.webbase module
=====================

class class webtav.webbase.BaseFlask(*args, **kwargs)

   Bases: "webtav.flasknado.Flasknado", "webtav.webbase.BaseTornado"

   Create a basic Flask object which looks and smells very much like a
   Tornado object. Pass through a copy of our Tornado app.

class class webtav.webbase.BaseTornado(*args, **kwargs)

   Bases: "webtav.webbase.XSRFBaseHandler"

   The default HTTPHandler for webtavern Tornado objects

   add_js(file=None, files=None)

      Add a Javascript file to this request

   get_template_namespace()

      Provides a dict of variables/functions that are available to
      templates.

      Returns:
         dict

   get_template_path()

      Returns the correct template path for the current theme.

      Currently this is using the chosen theme, but eventually we can
      default to mobile/etc here Overwrite to force a handler to use a
      specific theme (such as SiteMap)

   load_session(AllowGuestKey=True)

      Load into memory the User class by way of the session cookie.

      Generates a new user (usually guest) if it can't find one.

   save_session()

      Saves the current user to a session cookie. These are encrypted
      by Tornado.

   setheaders()

      Set various headers that each HTTP response should have.

   write_error(status_code, **kwargs)

      Catch exceptions and print out an error message using a
      template.

class class webtav.webbase.FlaskHandler(application, request, **kwargs)

   Bases: "webtav.webbase.XSRFBaseHandler"

   A *RequestHandler* instead calls Flask. This is needed so that we
   can properly load our own _XSRF records.

   initialize(fallback)

   prepare()

class class webtav.webbase.XSRFBaseHandler(application, request, **kwargs)

   Bases: "tornado.web.RequestHandler"

   A version of the Tornado RequestHandler with additional security in
   the XSRF token.

   check_xsrf_cookie()

      Verifies that the "_xsrf" cookie matches the "_xsrf" argument.

      To prevent cross-site request forgery, we set an "_xsrf" cookie
      and include the same value as a non-cookie field with all "POST"
      requests. If the two do not match, we reject the form submission
      as a potential forgery.

      The "_xsrf" value may be set as either a form field named
      "_xsrf" or in a custom HTTP header named "X-XSRFToken" or
      "X-CSRFToken" (the latter is accepted for compatibility with
      Django).

      See http://en.wikipedia.org/wiki/Cross-site_request_forgery

      Prior to release 1.1.1, this check was ignored if the HTTP
      header "X-Requested-With: XMLHTTPRequest" was present.  This
      exception has been shown to be insecure and has been removed.
      For more information please see
      http://www.djangoproject.com/weblog/2011/feb/08/security/
      http://weblog.rubyonrails.org/2011/2/8/csrf-protection-bypass-
      in-ruby-on-rails

   get_signed_cookie(name, value=None, max_age_days=31)

      Gets a secure cookie, via Tornado, and returns it as a Unicode
      string. :param name:The name of the cookie :param value
      (optional): If passed, get_signed_cookie will get the value from
      *value* instead of a cookie :return: Unicode string of the
      cookie

   is_secure

      Returns if the connection is loaded over https

   set_secure_cookie(name, value, **kwargs)

   xsrf_token

      The XSRF value is a randomly generated string that is set in
      both POST requests and cookies.

      Overwritten from the Tornado default to use systemrandom rather
      than uuid. Like tornado, this method will set a cookie with the
      xsrf value if it does not currently exist.

exception exception webtav.webbase.weberror(code=500, short=None, long=None, log=None, *args, **kwargs)

   Bases: "builtins.Exception"

   A generic http error message that supports subject/body.

   Raising the exception is preferred to calling write_error directly,
   This way we can log, look up errors in translation, etc.


webtav.webfront module
======================

class class webtav.webfront.AllMessagesHandler(*args, **kwargs)

   Bases: "webtav.webbase.BaseTornado"

   get()

      Display all messages.

class class webtav.webfront.AllSavedHandler(*args, **kwargs)

   Bases: "webtav.webbase.BaseTornado"

   get()

      Display all messages.

class class webtav.webfront.AvatarHandler(*args, **kwargs)

   Bases: "webtav.webbase.BaseTornado"

   Create Avatars using Robohashes. You should cache these on disk
   using nginx.

   get(avatar)

class class webtav.webfront.CatchallHandler(*args, **kwargs)

   Bases: "webtav.webbase.BaseTornado"

   Handler for any requests that aren't handled anywhere else. Returns
   404.

   delete()

   get()

   post()

   put()

class class webtav.webfront.EntryHandler(*args, **kwargs)

   Bases: "webtav.webbase.BaseTornado"

   get()

      A simple redirect, that will redirect people from / to a FAQ.

      Currently, this redirects everyone. Eventually, it may give a
      different experience for first-time visitors.

class class webtav.webfront.MessageHandler(*args, **kwargs)

   Bases: "webtav.webbase.BaseTornado"

   get(topic, short_sub, messageid)

      Displays a given message. Parameters Topic and Short_sub are
      ignored - They are in the URL for SEO reasons. :param topic:
      (not used) - The topic that the message is in. :param short_sub:
      (not used) - The Short version of the message's subject. :param
      messageid: The ID of the message

class class webtav.webfront.MessageHistoryHandler(*args, **kwargs)

   Bases: "webtav.webbase.BaseTornado"

   get(messageid, topic=None, short_name=None)

      Display the various edits to a message.

class class webtav.webfront.NewMessageHandler(*args, **kwargs)

   Bases: "webtav.webbase.BaseTornado"

   Create a new message.

   get(topic=None)

   options(flag=None)

class class webtav.webfront.RegisterHandler(*args, **kwargs)

   Bases: "webtav.webbase.BaseTornado"

   Register a new user for the site.

   get()

   post()

      Create the user in the DB, as requested.

class class webtav.webfront.ShowAllTopicsHandler(*args, **kwargs)

   Bases: "webtav.webbase.BaseTornado"

   Show every known topic

   get(page=0)

class class webtav.webfront.SiteContentHandler(*args, **kwargs)

   Bases: "webtav.webbase.BaseTornado"

   Displays site content, such as FAQ, Ettiquite, etc, without replies
   or other chrome.

   get(message)

class class webtav.webfront.SiteIndexHandler(*args, **kwargs)

   Bases: "webtav.webbase.BaseTornado"

   get()

      Return a sitemap index file, which includes all other sitemap
      files. Since each sitemap.xml file can only contain 50K urls, we
      need to split these.

   get_template_path()

      Force this request out of the robots folder, since it's not for
      people.

class class webtav.webfront.SitemapMessagesHandler(*args, **kwargs)

   Bases: "webtav.webbase.BaseTornado"

   get(iteration)

      Create a sitemap.xml file to show a slice of messages.

   get_template_path()

      Force this request out of the robots folder, since it's not for
      people.

class class webtav.webfront.TopicHandler(*args, **kwargs)

   Bases: "webtav.webbase.BaseTornado"

   get(topic)

      Display the messages for a given topic

class class webtav.webfront.TopicPropertiesHandler(*args, **kwargs)

   Bases: "webtav.webbase.BaseTornado"

   Show Properties for a topic

   get(topic)

class class webtav.webfront.UploadAttachmentHandler(*args, **kwargs)

   Bases: "webtav.webfront.UploadMessageHandler"

   methods = ['POST']

   post()

      Receive a POST request containing a file from JS, and return the
      JSON formatted reply it's expecting.

class class webtav.webfront.UploadMessageHandler(*args, **kwargs)

   Bases: "webtav.webbase.BaseFlask"

   methods = ['POST']

   post()

      Receive Envelopes and their attachments.

   receive_files()

      Receive files, save them out.

   sign_and_deliver(envelope)

      Sign the message with the Author's info, and upload to the
      server. :return: ID of insert (if successful)

class class webtav.webfront.UploadMessageRevisionHandler(*args, **kwargs)

   Bases: "webtav.webfront.UploadMessageHandler"

   Upload a revision to an earlier message.

   methods = ['POST']

   post()

      Receive Envelopes and their attachments.

class class webtav.webfront.UploadPrivateMessageHandler(*args, **kwargs)

   Bases: "webtav.webfront.UploadMessageHandler"

   Receive text, encrypt, send to dest.

   methods = ['POST']

   post()

class class webtav.webfront.UserHandler(*args, **kwargs)

   Bases: "webtav.webbase.BaseTornado"

   Print the User's information

   If this is your account, also shows an UI to change settings.

   get(pubkey)

class class webtav.webfront.XSRFHandler(application, request, **kwargs)

   Bases: "webtav.webbase.XSRFBaseHandler"

   The XSRF handler returns a xsrf token

   This handler's output is included into the header via nginx SSI. By
   importing via SSI, nginx can cache the output from other handlers.

   Otherwise, each request from a non-logged in user would do a full
   page-load, since the Set-Cookie would bypass the cache.

   We do need a separate token for each request, since the site
   contains a login form. Combining them in nginx lets us have a
   separate xsrf value while still caching on sessionid.

   This inherits from XSRFBaseHandler so that it bypasses the regular
   login/session path.

   get()

      Internal only handler that returns the xsrf token. This is
      called by nginx, not accessible to the outside world.

   get_template_path()

      Force this request out of the robots folder, since it's not for
      people.

webtav.webfront.main()

   Starts and runs the Python component of the Tavern web interface.
   You are NOT supposed to connect to Tornado directly, connections
   MUST go through Nginx. Nginx will connect to tornado through a
   domain socket.


Module contents
===============
